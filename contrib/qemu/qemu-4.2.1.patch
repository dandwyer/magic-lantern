diff -u a/include/qemu/bswap.h b/include/qemu/bswap.h
--- a/include/qemu/bswap.h
+++ b/include/qemu/bswap.h
@@ -2,6 +2,7 @@
 #define BSWAP_H
 
 #include "fpu/softfloat-types.h"
+#include "qemu/compiler.h"
 
 #ifdef CONFIG_MACHINE_BSWAP_H
 # include <sys/endian.h>
diff --git a/hw/usb/bus.c b/hw/usb/bus.c
--- a/hw/usb/bus.c
+++ b/hw/usb/bus.c
@@ -401,7 +401,7 @@
 void usb_port_location(USBPort *downstream, USBPort *upstream, int portnr)
 {
     if (upstream) {
-        int l = snprintf(downstream->path, sizeof(downstream->path), "%s.%d",
+        int l = snprintf(downstream->path, sizeof(downstream->path), "%.12s.%d",
                          upstream->path, portnr);
         /* Max string is nn.nn.nn.nn.nn, which fits in 16 bytes */
         assert(l < sizeof(downstream->path));
diff -u a/hw/eos/serial_flash.h b/hw/eos/serial_flash.h
--- a/hw/eos/serial_flash.h
+++ b/hw/eos/serial_flash.h
@@ -2,7 +2,7 @@
 #define SERIAL_FLASH_H
 
 #include <stdint.h>
-#include <eos.h>
+#include "hw/eos/eos.h"
 
 #define RDID_MACRONIX {0xC2,0x10,0x0C}
 
diff -u a/hw/eos/serial_flash.c b/hw/eos/serial_flash.c
--- a/hw/eos/serial_flash.c
+++ b/hw/eos/serial_flash.c
@@ -3,6 +3,8 @@
 #include <stdint.h>
 #include <string.h>

+#include "qemu/osdep.h"
+#include "qemu/log.h"
 #include "eos.h"
 #include "hw/sd/sd.h"
 #include "hw/eos/serial_flash.h"
diff -u a/hw/eos/mpu.c b/hw/eos/mpu.c
--- a/hw/eos/mpu.c
+++ b/hw/eos/mpu.c
@@ -2,6 +2,9 @@
 #include <stdlib.h>
 #include <stdint.h>
 
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "sysemu/runstate.h"
 #include "eos.h"
 #include "model_list.h"
 #include "mpu.h"
@@ -233,7 +236,7 @@
 {
     MPU_EPRINTF("Shutdown requested.\n");
     clean_shutdown = 1;
-    qemu_system_shutdown_request();
+    qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
 }

 static void mpu_interpret_command(EOSState *s)
diff -u a/hw/eos/eos_ml_helpers.c b/hw/eos/eos_ml_helpers.c
--- a/hw/eos/eos_ml_helpers.c
+++ b/hw/eos/eos_ml_helpers.c
@@ -4,7 +4,8 @@
 #include <stdint.h>
 #include <string.h>
 
-
+#include "qemu/osdep.h"
+#include "disas/disas.h"
 #include "sysemu/sysemu.h"
 #include "eos.h"
 #include "eos_ml_helpers.h"
@@ -57,7 +58,7 @@
                     uint32_t bits = eos_get_mem_h(s, value & ~1) >> 11;
                     size = (bits == 0b11101 || bits == 0b11110 || bits == 0b11111) ? 4 : 2;
                 }
-                target_disas(stderr, CPU(arm_env_get_cpu(&s->cpu0->env)), value, size, 0);
+                target_disas(stderr, CPU(env_archcpu(&s->cpu0->env)), value, size);
                 fprintf(stderr, KRESET);
                 return 0;
         }
diff -u a/hw/eos/eos.h b/hw/eos/eos.h
--- a/hw/eos/eos.h
+++ b/hw/eos/eos.h
@@ -2,6 +2,8 @@
 
 #define HW_EOS_H
 
+//#include "hw/hw.h"
+#include "target/arm/cpu.h"
 #include "hw/sysbus.h"
 #include "hw/sd/sd.h"
 #include "hw/ide/internal.h"
diff -u a/hw/eos/engine.c b/hw/eos/engine.c
--- a/hw/eos/engine.c
+++ b/hw/eos/engine.c
@@ -7,6 +7,8 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <math.h>
+#include "qemu/osdep.h"
+#include "hw/hw.h"
 #include "eos.h"
 #include "engine.h"
 #include "model_list.h"
diff -u a/hw/eos/dbi/memcheck.c b/hw/eos/dbi/memcheck.c
--- a/hw/eos/dbi/memcheck.c
+++ b/hw/eos/dbi/memcheck.c
@@ -3,6 +3,7 @@
 #include <stdint.h>

 #include "qemu/osdep.h"
+#include "qemu/log.h"
 #include "qapi/error.h"
 #include "cpu.h"
 

diff -u a/hw/eos/dbi/logging.c b/hw/eos/dbi/logging.c
--- a/hw/eos/dbi/logging.c
+++ b/hw/eos/dbi/logging.c
@@ -3,6 +3,10 @@
 #include <stdint.h>
 
 #include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "disas/disas.h"
+#include "exec/exec-all.h"
+#include "exec/log.h"
 #include "qapi/error.h"
 #include "cpu.h"
 #include "elf.h"
@@ -186,7 +190,8 @@
     /* fixme: can be slow */
     hwaddr l = 4;
     hwaddr addr1;
-    MemoryRegion * mr = address_space_translate(&address_space_memory, addr, &addr1, &l, is_write);
+    MemoryRegion * mr = address_space_translate(&address_space_memory, addr, &addr1, &l, is_write,
+                                                MEMTXATTRS_UNSPECIFIED);
 
     if (!should_log_memory_region(mr, is_write))
     {
@@ -323,8 +328,8 @@
         assert(stderr_dup);
         fflush(stderr); fflush(idc);
         dup2(fileno(idc), fileno(stderr));
-        fprintf(stderr, "  /* from "); log_target_disas(cpu, prev_pc, prev_size, 0);
-        fprintf(stderr, "   *   -> "); log_target_disas(cpu, tb->pc, tb->size, 0);
+        fprintf(stderr, "  /* from "); log_target_disas(cpu, prev_pc, prev_size);
+        fprintf(stderr, "   *   -> "); log_target_disas(cpu, tb->pc, tb->size);
         char * task_name = eos_get_current_task_name(s);
         fprintf(stderr, "   * %s%sPC:%x->%x LR:%x->%x SP:%x */\n",
             task_name ? task_name : "", task_name ? " " : "",
@@ -372,7 +377,7 @@
     uint32_t is_tail_call;      /* boolean: whether it's a tail function call */
     uint32_t interrupt_id;      /* 0 = regular code, nonzero = interrupt */
     uint32_t direct_jumps[4];   /* DIGIC 6 code uses many of those */
-} __attribute__((packed));
+};

 static struct call_stack_entry call_stacks[256][256];
 static int call_stack_num[256] = {0};
@@ -686,7 +691,8 @@
 {
     hwaddr l = len;
     hwaddr addr1;
-    MemoryRegion * mr = address_space_translate(&address_space_memory, ptr, &addr1, &l, 0);
+    MemoryRegion * mr = address_space_translate(&address_space_memory, ptr, &addr1, &l, 0,
+                                                MEMTXATTRS_UNSPECIFIED);
 
     if (!mr)
     {
@@ -1568,7 +1574,7 @@
                 /* hm, target_disas used to look at flags for ARM or Thumb... */
                 int t0 = env->thumb; env->thumb = prev_pc & 1;
                 assert(prev_size);
-                target_disas(stderr, CPU(arm_env_get_cpu(env)), prev_pc0, prev_size, 0);
+                target_disas(stderr, CPU(env_archcpu(env)), prev_pc0, prev_size);
                 env->thumb = t0;
             }
         }
@@ -1655,7 +1661,8 @@
 
     hwaddr l = block_size;
     hwaddr block_rom_start_rel;
-    MemoryRegion * mr = address_space_translate(&address_space_memory, block_rom_start, &block_rom_start_rel, &l, 0);
+    MemoryRegion * mr = address_space_translate(&address_space_memory, block_rom_start, &block_rom_start_rel, &l, 0,
+                                                MEMTXATTRS_UNSPECIFIED);
     assert(l == block_size);
 
     if (strcmp(mr->name, "eos.rom0") == 0 ||
@@ -1877,7 +1884,8 @@
 {
     fprintf(stderr, "[EOS] loading symbols from %s ", elf_filename);
     uint64_t lo, hi;
-    int size = load_elf(elf_filename, 0, 0, 0, &lo, &hi, 0, EM_ARM, 1);
+    int size = load_elf(elf_filename, NULL, NULL, NULL, NULL,
+                        &lo, &hi, 0, EM_ARM, 1, 0);
     fprintf(stderr, "(%X - %X)\n", (int) lo, (int) hi);
     assert(size > 0);
 }
diff -u a/hw/eos/dbi/backtrace.c b/hw/eos/dbi/backtrace.c
--- a/hw/eos/dbi/backtrace.c
+++ b/hw/eos/dbi/backtrace.c
@@ -38,6 +38,8 @@
 #include <stdint.h>

 #include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "disas/disas.h"
 #include "qapi/error.h"
 #include "cpu.h"

@@ -258,7 +260,7 @@
     if (qemu_loglevel_mask(BKT_LOG_DISAS))
     {
         CPUARMState *env = &(CURRENT_CPU->env);
-        target_disas(stderr, CPU(arm_env_get_cpu(env)), pc, 4, 0);
+        target_disas(stderr, CPU(env_archcpu(env)), pc, 4);
     }
 #endif

@@ -833,7 +835,7 @@
             {
                 fprintf(stderr, "SP mismatch: expected %x->%x, got %x (=> %x at %x,%x)\n", prev_sp, sp, ssp, ret, prev_pc, pc);
                 CPUARMState *env = &(CURRENT_CPU->env);
-                target_disas(stderr, CPU(arm_env_get_cpu(env)), prev_pc, 4, 0);
+                target_disas(stderr, CPU(env_archcpu(env)), prev_pc, 4);
                 assert(0);
             }

@@ -853,7 +855,7 @@
                 }
                 fprintf(stderr, "LR mismatch: expected %x->%x, got %x (=> %x at %x,%x)\n", prev_lr, lr, slr, ret, prev_pc, pc);
                 CPUARMState *env = &(CURRENT_CPU->env);
-                target_disas(stderr, CPU(arm_env_get_cpu(env)), prev_pc, 4, 0);
+                target_disas(stderr, CPU(env_archcpu(env)), prev_pc, 4);
                 //assert(0);
             }
         }

diff --git a/default-configs/arm-softmmu.mak b/default-configs/arm-softmmu.mak
index 1f2e0e7f..cc5f7eb8 100644
--- a/default-configs/arm-softmmu.mak
+++ b/default-configs/arm-softmmu.mak
@@ -28,6 +28,7 @@ CONFIG_SPITZ=y
 CONFIG_TOSA=y
 CONFIG_Z2=y
 CONFIG_COLLIE=y
+CONFIG_EOS=y
 CONFIG_ASPEED_SOC=y
 CONFIG_NETDUINO2=y
 CONFIG_MPS2=y
diff --git a/hw/arm/Kconfig b/hw/arm/Kconfig
index c6e77825..5896cb42 100644
--- a/hw/arm/Kconfig
+++ b/hw/arm/Kconfig
@@ -39,6 +39,11 @@ config DIGIC
     select PTIMER
     select PFLASH_CFI02
 
+config EOS
+    bool
+    select PTIMER
+    select PFLASH_CFI02
+
 config EXYNOS4
     bool
     select A9MPCORE
diff -u a/hw/Makefile.objs b/hw/Makefile.objs
--- a/hw/Makefile.objs
+++ b/hw/Makefile.objs
@@ -10,6 +10,7 @@
 devices-dirs-y += cpu/
 devices-dirs-y += display/
 devices-dirs-y += dma/
+devices-dirs-$(CONFIG_EOS) += eos/
 devices-dirs-y += gpio/
 devices-dirs-$(CONFIG_HYPERV) += hyperv/
 devices-dirs-$(CONFIG_I2C) += i2c/
diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index c88d0ff..4395bb3 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -391,6 +391,16 @@ static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,
     qemu_spin_unlock(&tb_next->jmp_lock);
     return;
 }
 
+static void (*tb_exec_cb)(void *opaque, CPUState *cpu, TranslationBlock *tb);
+static void * tb_exec_opaque;
+
+void cpu_set_tb_exec_cb(void (*cb)(void *opaque, CPUState *cpu, TranslationBlock *tb),
+                        void *opaque)
+{
+    tb_exec_cb = cb;
+    tb_exec_opaque = opaque;
+}
+
 static inline TranslationBlock *tb_find(CPUState *cpu,
                                         TranslationBlock *last_tb,
                                         int tb_exit, uint32_t cf_mask)
@@ -417,6 +417,9 @@ static inline TranslationBlock *tb_find(CPUState *cpu,
         last_tb = NULL;
     }
 #endif
+    if (tb_exec_cb) {
+        tb_exec_cb(tb_exec_opaque, cpu, tb);
+    }
     /* See if we can patch the calling TB. */
     if (last_tb) {
         tb_add_jump(last_tb, tb_exit, tb);
diff --git a/disas/arm.c b/disas/arm.c
index 7a7354b..95f82cc 100644
--- a/disas/arm.c
+++ b/disas/arm.c
@@ -2826,9 +2826,9 @@ print_insn_arm_internal (bfd_vma pc, struct disassemble_info *info, long given)
 		      if ((given & 0x02000000) != 0)
 			{
 			  int rotate = (given & 0xf00) >> 7;
-			  int immed = (given & 0xff);
-			  immed = (((immed << (32 - rotate))
-				    | (immed >> rotate)) & 0xffffffff);
+			  int64_t immed64 = (given & 0xff);
+			  int immed = (((immed64 << (32 - rotate))
+				      | (immed64 >> rotate)) & 0xffffffff);
 			  func (stream, "#%d\t; 0x%x", immed, immed);
 			}
 		      else
@@ -3868,7 +3868,7 @@ int
 print_insn_arm (bfd_vma pc, struct disassemble_info *info)
 {
   unsigned char b[4];
-  long		given;
+  unsigned long given;
   int           status;
   int           is_thumb = false;
   int           is_data = false;
diff --git a/hw/arm/digic.c b/hw/arm/digic.c
index 90f8190..8e934be 100644
--- a/hw/arm/digic.c
+++ b/hw/arm/digic.c
@@ -36,7 +36,7 @@ static void digic_init(Object *obj)
     object_property_add_child(obj, "cpu", OBJECT(&s->cpu), NULL);
 
     for (i = 0; i < DIGIC4_NB_TIMERS; i++) {
-#define DIGIC_TIMER_NAME_MLEN    11
+#define DIGIC_TIMER_NAME_MLEN    20
         char name[DIGIC_TIMER_NAME_MLEN];
 
         object_initialize(&s->timer[i], sizeof(s->timer[i]), TYPE_DIGIC_TIMER);
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index d900b0d..1ad5332 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -405,4 +405,7 @@ extern int singlestep;
 extern CPUState *tcg_current_cpu;
 extern bool exit_request;
 
+void cpu_set_tb_exec_cb(void (*cb)(void *opaque, CPUState *cpu, TranslationBlock *tb),
+                        void *opaque);
+
 #endif
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 0f07159..40c3940 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -1356,6 +1356,19 @@ void address_space_unmap(AddressSpace *as, void *buffer, hwaddr len,
                          int is_write, hwaddr access_len);
 
 
+/* memory_set_access_logging_cb: allow logging guest memory accesses
+ * using callbacks.
+ * 
+ * Currently implemented only for ARM 32-bit (LDR/STR).
+ * 
+ * @mem_log_cb: callback to be called when memory access takes place
+ * @opaque: argument passed to mem_log_cb
+ * @access_mode: bit field (PROT_READ, PROT_WRITE); fixme - better constants? define new ones?
+ */
+void memory_set_access_logging_cb(
+    void (*mem_log_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write),
+    void * opaque, int access_mode);
+
 #endif
 
 #endif
diff --git a/include/hw/elf_ops.h b/include/hw/elf_ops.h
index 0010c44..d85cc6b 100644
--- a/include/hw/elf_ops.h
+++ b/include/hw/elf_ops.h
@@ -140,8 +140,11 @@ static int glue(load_symbols, SZ)(struct elfhdr *ehdr, int fd, int must_swab,
         /* We are only interested in function symbols.
            Throw everything else away.  */
         if (syms[i].st_shndx == SHN_UNDEF ||
-                syms[i].st_shndx >= SHN_LORESERVE ||
-                ELF_ST_TYPE(syms[i].st_info) != STT_FUNC) {
+           (!(syms[i].st_shndx == SHN_ABS &&         /* allow ABS symbols (ML stubs) */
+              ELF_ST_TYPE(syms[i].st_info) == STT_NOTYPE &&
+              syms[i].st_size == 0) &&
+              (syms[i].st_shndx >= SHN_LORESERVE ||
+               ELF_ST_TYPE(syms[i].st_info) != STT_FUNC))) {
             nsyms--;
             if (i < nsyms) {
                 syms[i] = syms[nsyms];
@@ -157,9 +160,13 @@ static int glue(load_symbols, SZ)(struct elfhdr *ehdr, int fd, int must_swab,
     syms = g_realloc(syms, nsyms * sizeof(*syms));
 
     qsort(syms, nsyms, sizeof(*syms), glue(symcmp, SZ));
-    for (i = 0; i < nsyms - 1; i++) {
+    for (i = 0; i < nsyms; i++) {
         if (syms[i].st_size == 0) {
-            syms[i].st_size = syms[i + 1].st_value - syms[i].st_value;
+            if (syms[i].st_shndx == SHN_ABS) {
+                syms[i].st_size = 4;
+            } else if (i + 1 < nsyms) {
+                syms[i].st_size = syms[i + 1].st_value - syms[i].st_value;
+            }
         }
     }
 
diff --git a/include/qemu/log.h b/include/qemu/log.h
index 362cbc4..7859c5f 100644
--- a/include/qemu/log.h
+++ b/include/qemu/log.h
@@ -47,6 +42,47 @@ static inline bool qemu_log_enabled(void)
 #define CPU_LOG_TB_FPU     (1 << 17)
 #define CPU_LOG_PLUGIN     (1 << 18)
 
+/* various EOS options */
+/* some of them are just defined for future use */
+#define EOS_LOG_IO         (1LL << 21)
+#define EOS_LOG_IO_LOG     (1LL << 22)
+#define EOS_LOG_UART       (1LL << 23)
+#define EOS_LOG_MPU        (1LL << 24)
+#define EOS_LOG_SDCF       (1LL << 25)
+#define EOS_LOG_SFLASH     (1LL << 26)
+#define EOS_LOG_PFLASH     (1LL << 27)
+#define EOS_LOG_DMA        (1LL << 28)
+#define EOS_LOG_EDMAC      (1LL << 29)
+
+#define EOS_LOG_VERBOSE    (1LL << 32)
+#define EOS_LOG_AUTOEXEC   (1LL << 33)
+
+/* guest memory tracing (logging) */
+#define EOS_LOG_RAM_R      (1LL << 40)      /* memory logging backends */
+#define EOS_LOG_RAM_W      (1LL << 41)      /* used by other analysis tools, but not printed directly */
+#define EOS_LOG_ROM_R      (1LL << 42)      /* these backends have additional overhead on generated code */
+#define EOS_LOG_ROM_W      (1LL << 43)      /* so they are only enabled when actually used */
+#define EOS_LOG_RAM        (EOS_LOG_RAM_R | EOS_LOG_RAM_W)
+#define EOS_LOG_ROM        (EOS_LOG_ROM_R | EOS_LOG_ROM_W)
+#define EOS_LOG_MEM_R      (EOS_LOG_RAM_R | EOS_LOG_ROM_R)
+#define EOS_LOG_MEM_W      (EOS_LOG_RAM_W | EOS_LOG_ROM_W)
+#define EOS_LOG_MEM        (EOS_LOG_RAM   | EOS_LOG_ROM)
+#define EOS_PR(mem_flag)  ((mem_flag) << 4) /* memory logging printed in logs (duplicate the above flags) */
+                                            /* this will take 4 bits: 40-43 => 44-47 */
+#define EOS_LOG_RAM_DBG    (1LL << 48)      /* self-test */
+#define EOS_LOG_TASKS      (1LL << 49)      /* task switches */
+#define EOS_LOG_DEBUGMSG   (1LL << 50)      /* DebugMsg calls */
+
+/* analysis tools */
+#define EOS_LOG_CALLSTACK  (1LL << 51)      /* backend: provide call stack to other tools */
+#define EOS_LOG_CALLS      (1LL << 52)      /* log all calls and returns to console */
+#define EOS_LOG_IDC        (1LL << 53)      /* export unique calls to IDA */
+#define EOS_LOG_RAM_MEMCHK (1LL << 54)      /* like valgrind memcheck */
+#define EOS_LOG_RAM_TSKMEM (1LL << 55)      /* check task memory ownership assumptions */
+#define EOS_LOG_RAM_SEMCHK (1LL << 56)      /* check semaphore usage (like helgrind) */
+#define EOS_LOG_ROMCPY     (1LL << 57)      /* find memory blocks copied from ROM to RAM */
+#define EOS_LOG_NO_TAIL_CALLS (1LL << 58)   /* don't attempt to identify tail calls */
+
 /* Lock output for a series of related logs.  Since this is not needed
  * for a single qemu_log / qemu_log_mask / qemu_log_mask_and_addr, we
  * assume that qemu_loglevel_mask has already been tested, and that
@@ -147,7 +147,7 @@ static inline void qemu_log_set_file(FILE *f)
 
 /* define log items */
 typedef struct QEMULogItem {
-    int mask;
+    uint64_t mask;
     const char *name;
     const char *help;
 } QEMULogItem;
@@ -154,12 +154,12 @@ extern const QEMULogItem qemu_log_items[];
 
 extern const QEMULogItem qemu_log_items[];
 
-void qemu_set_log(int log_flags);
+void qemu_set_log(uint64_t log_flags);
 void qemu_log_needs_buffers(void);
 void qemu_set_log_filename(const char *filename, Error **errp);
 void qemu_set_dfilter_ranges(const char *ranges, Error **errp);
 bool qemu_log_in_addr_range(uint64_t addr);
-int qemu_str_to_log_mask(const char *str);
+uint64_t qemu_str_to_log_mask(const char *str);
 
 /* Print a usage message listing all the valid logging categories
  * to the specified FILE*.
--- a/include/exec/log.h
+++ b/include/exec/log.h
@@ -28,7 +28,7 @@ static inline void log_cpu_state(CPUState *cpu, int flags)
  *
  * Logs the output of cpu_dump_state() if loglevel includes @mask.
  */
-static inline void log_cpu_state_mask(int mask, CPUState *cpu, int flags)
+static inline void log_cpu_state_mask(uint64_t mask, CPUState *cpu, int flags)
 {
     if (qemu_loglevel & mask) {
         log_cpu_state(cpu, flags);
--- a/include/qemu/log-for-trace.h
+++ b/include/qemu/log-for-trace.h
@@ -19,12 +19,12 @@
 #define QEMU_LOG_FOR_TRACE_H
 
 /* Private global variable, don't use */
-extern int qemu_loglevel;
+extern uint64_t qemu_loglevel;
 
 #define LOG_TRACE          (1 << 15)
 
 /* Returns true if a bit is set in the current loglevel mask */
-static inline bool qemu_loglevel_mask(int mask)
+static inline bool qemu_loglevel_mask(uint64_t mask)
 {
     return (qemu_loglevel & mask) != 0;
 }
diff --git a/memory.c b/memory.c
index e193658..9de7251 100644
--- a/memory.c
+++ b/memory.c
@@ -2397,6 +2397,9 @@ void memory_region_add_subregion(MemoryRegion *mr,
                                  hwaddr offset,
                                  MemoryRegion *subregion)
 {
+    fprintf(stderr, "%08X - %08X: %s\n",
+                     (int)offset, (int)offset + (int)int128_getlo(subregion->size) - 1,
+                     subregion->name);
     subregion->priority = 0;
     memory_region_add_subregion_common(mr, offset, subregion);
 }
diff --git a/util/log.c b/util/log.c
index 7cb01a8..7b57b2e 100644
--- a/util/log.c
+++ b/util/log.c
@@ -27,7 +27,7 @@
 
 static char *logfilename;
 FILE *qemu_logfile;
-int qemu_loglevel;
+uint64_t qemu_loglevel;
 static int log_append = 0;
 static GArray *debug_regions;
 
@@ -52,7 +52,7 @@
 static bool log_uses_own_buffers;
 
 /* enable or disable low levels log */
-void qemu_set_log(int log_flags)
+void qemu_set_log(uint64_t log_flags)
 {
     qemu_loglevel = log_flags;
 #ifdef CONFIG_TRACE_LOG
@@ -268,23 +268,79 @@ const QEMULogItem qemu_log_items[] = {
       "log unimplemented functionality" },
     { LOG_GUEST_ERROR, "guest_errors",
       "log when the guest OS does something invalid (eg accessing a\n"
-      "non-existent register)" },
+      "           non-existent register)" },
     { CPU_LOG_PAGE, "page",
       "dump pages at beginning of user mode emulation" },
     { CPU_LOG_TB_NOCHAIN, "nochain",
       "do not chain compiled TBs so that \"exec\" and \"cpu\" show\n"
-      "complete traces" },
+      "           complete traces; implies -singlestep" },
 #ifdef CONFIG_PLUGIN
     { CPU_LOG_PLUGIN, "plugin", "output from TCG plugins\n"},
 #endif
+    { EOS_LOG_IO | CPU_LOG_TB_NOCHAIN, "io",
+      "EOS: log low-level I/O activity (implies nochain,singlestep)" },
+    { EOS_LOG_IO, "io_quick",
+      "EOS: log low-level I/O activity (without nochain,singlestep; PC not exact)" },
+    { EOS_LOG_IO_LOG | EOS_LOG_IO | CPU_LOG_TB_NOCHAIN, "io_log",
+      "EOS: for every I/O read, export a mmio_log entry to use in dm-spy-extra.c\n"
+      "                (dm-spy-experiments branch) to see the values from physical hardware." },
+    { EOS_LOG_MPU, "mpu",
+      "EOS: log low-level MPU activity" },
+    { EOS_LOG_SFLASH, "sflash",
+      "EOS: log low-level serial flash activity" },
+    { EOS_LOG_SDCF, "sdcf",
+      "EOS: log low-level SD/CF activity" },
+    { EOS_LOG_UART, "uart",
+      "EOS: log low-level UART activity" },
+
+    { EOS_PR(EOS_LOG_RAM) | EOS_LOG_RAM, "ram",
+      "EOS: log all RAM reads and writes" },
+    { EOS_PR(EOS_LOG_ROM) | EOS_LOG_ROM, "rom",
+      "EOS: log all ROM reads and writes" },
+    { EOS_PR(EOS_LOG_RAM_R) | EOS_LOG_RAM_R, "ramr",
+      "EOS: log all RAM reads" },
+    { EOS_PR(EOS_LOG_ROM_R) | EOS_LOG_ROM_R, "romr",
+      "EOS: log all ROM reads" },
+    { EOS_PR(EOS_LOG_RAM_W) | EOS_LOG_RAM_W, "ramw",
+      "EOS: log all RAM writes" },
+    { EOS_PR(EOS_LOG_ROM_W) | EOS_LOG_ROM_W, "romw",
+      "EOS: log all ROM writes" },
+    { EOS_LOG_RAM_DBG | EOS_LOG_RAM, "ram_dbg",
+      "EOS: self-test for the RAM logging routines" },
+
+    { EOS_LOG_CALLSTACK | CPU_LOG_TB_NOCHAIN, "callstack",
+      "EOS: reconstruct call stack (implies nochain,singlestep)" },
+    { EOS_LOG_CALLS | EOS_LOG_CALLSTACK | CPU_LOG_TB_NOCHAIN | EOS_LOG_RAM_R, "calls",
+      "EOS: log function calls (implies callstack,nochain,singlestep; monitors RAM reads)" },
+    { EOS_LOG_NO_TAIL_CALLS, "notail",
+      "EOS: don't identify tail calls (for troubleshooting)" },
+    { EOS_LOG_IDC | EOS_LOG_CALLSTACK | CPU_LOG_TB_NOCHAIN, "idc",
+      "EOS: export called functions to IDA (implies callstack,nochain,singlestep)" },
+    { EOS_LOG_TASKS, "tasks",
+      "EOS: log task switches (.current_task_addr must be defined)" },
+    { EOS_LOG_DEBUGMSG, "debugmsg",
+      "EOS: log DebugMsg calls (QEMU_EOS_DEBUGMSG must be defined)" },
+    { EOS_LOG_ROMCPY | EOS_LOG_ROM_R | EOS_LOG_RAM_W, "romcpy",
+      "EOS: find memory blocks copied from ROM to RAM" },
+
+    { EOS_LOG_RAM_MEMCHK | EOS_LOG_RAM, "memchk",
+      "EOS: check memory usage (malloc/free, uninitialized values)" },
+
+    { EOS_LOG_AUTOEXEC, "autoexec",
+      "EOS: start verbose logging when autoexec.bin is loaded (quiet logging for bootloader)" },
+
+    { EOS_LOG_VERBOSE, "v", "" },
+    { EOS_LOG_VERBOSE, "verbose",
+      "EOS: very detailed debug messages" },
+
     { 0, NULL, NULL },
 };
 
 /* takes a comma separated list of log masks. Return 0 if error. */
-int qemu_str_to_log_mask(const char *str)
+uint64_t qemu_str_to_log_mask(const char *str)
 {
     const QEMULogItem *item;
-    int mask = 0;
+    uint64_t mask = 0;
     char **parts = g_strsplit(str, ",", 0);
     char **tmp;
 
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 25fb1ce..c180f78 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -868,6 +868,7 @@ typedef struct ARMCPU {
     uint32_t revidr;
     uint32_t reset_fpsid;
     uint32_t ctr;
+    uint32_t tcmtr;
     uint32_t reset_sctlr;
     uint32_t id_pfr0;
     uint32_t id_pfr1;
diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 30739fc..e332483 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -979,6 +979,7 @@ static void arm_cpu_initfn(Object *obj)
 static Property arm_cpu_reset_cbar_property =
             DEFINE_PROP_UINT64("reset-cbar", ARMCPU, reset_cbar, 0);
 
+/* fixme: how to change this property from machine code? */
 static Property arm_cpu_reset_hivecs_property =
             DEFINE_PROP_BOOL("reset-hivecs", ARMCPU, reset_hivecs, false);
 
@@ -1723,7 +1723,104 @@ static void arm926_initfn(Object *obj)
     cpu->isar.mvfr0 = FIELD_DP32(cpu->isar.mvfr0, MVFR0, FPSHVEC, 1);
     cpu->isar.mvfr0 = FIELD_DP32(cpu->isar.mvfr0, MVFR0, FPDP, 1);
 }
+ 
+static void arm946_eos_initfn(Object *obj)
+{
+    /* https://chdk.setepontos.com/index.php?topic=2139.msg19836#msg19836 */
+    ARMCPU *cpu = ARM_CPU(obj);
+    set_feature(&cpu->env, ARM_FEATURE_V5);
+    set_feature(&cpu->env, ARM_FEATURE_PMSA);
+    cpu->midr        = 0x41059461;
+    cpu->ctr         = 0x0F112112;                /* DIGIC 5: 0x0F192192 */
+    cpu->tcmtr       = 0x000C00C0;
+    cpu->reset_sctlr = 0x00000078 | (1 << 13);    /* fixme: how to change the HIVECS property? */
+    set_feature(&cpu->env, ARM_FEATURE_946EOS);
+}
+
+static void arm946_eos5_initfn(Object *obj)
+{
+    /* mostly identical to DIGIC 2..4, with minor differences */
+    arm946_eos_initfn(obj);
+
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->ctr = 0x0F192192;
+}
+
+static void cortex_r5_initfn(Object *obj);
+
+static void cortex_r4_eos_initfn(Object *obj)
+{
+    /* Cortex R4: https://chdk.setepontos.com/index.php?topic=11316.msg124273#msg124273 */
+    cortex_r5_initfn(obj);
+
+    /* https://www.magiclantern.fm/forum/index.php?topic=17714.0 */
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->midr = 0x411FC143;
+    cpu->ctr = 0x8003C003;
+    cpu->tcmtr = 0x00010001;
+    cpu->id_mmfr3 = 0x00000011;
+    cpu->isar.id_isar0 = 0x01101111;
+    cpu->isar.id_isar2 = 0x21232131;
+    cpu->clidr = 0x09000003;
+    cpu->ccsidr[0] = 0xF00FE019;
+    cpu->ccsidr[1] = 0xF00FE019;
+    cpu->dbgdidr = 0x77040013;  /* https://www.magiclantern.fm/forum/index.php?topic=17360.msg202322#msg202322 */
+    cpu->reset_sctlr = 0x08E50878 | (1 << 13);    /* fixme: how to change the HIVECS property? */
+    //        1=MPU,        2=align,      4=DCacheL1,  8=SBO        => 8
+    //       10=SBO,       20=SBO,       40=SBO,      80=SBZ        => 7
+    //      100=SBZ,      200=SBZ,      400=SBZ,     800=Z(SBO)     => 8
+    //     1000=ICacheL1,2000=HIVECS,  4000=RR,     8000=SBZ        => 2 (1 << 13)
+    //    10000=SBO,    20000=BR,     40000=SBO,   80000=DZ         => 5
+    //   100000=SBZ,   200000=FI/SBO,400000=SBO,  800000=SBO        => E
+    //  1000000=VE,   2000000=EE,   4000000=SBZ, 8000000=NMFIQ      => 8
+    // 10000000=TRE, 20000000=AFE, 40000000=TE, 80000000=IE         => 0
+    // bic                0x20000   (disable background region)
+    // orr                    0x1   (enable MPU)
+    // bic              0x1002000   (disable HIVECS, VE?!)
+    // orr                   1004   (enable L1 DCache & ICache)
+    // ->reset_sctlr = 0x08E5187D;  /* as printed by CHDK cpuinfo running from bootloader */
+    cpu->reset_auxcr = 0x00000020;  /* ACTLR */
+    unset_feature(&cpu->env, ARM_FEATURE_V7MP);
+}
+
+static void cortex_a9_initfn(Object *obj);
+
+static void cortex_a9_eos_initfn(Object *obj)
+{
+    /* Cortex A9: http://chdk.setepontos.com/index.php?topic=13014.msg131110#msg131110 */
+    cortex_a9_initfn(obj);
+
+    /* https://www.magiclantern.fm/forum/index.php?topic=19737.msg200737#msg200737 */
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->midr = 0x414FC091;
+    cpu->ctr = 0x83338003;
+    cpu->id_pfr0 = 0x00001231;
+    cpu->id_pfr1 = 0x00000011;
+    cpu->id_dfr0 = 0x00010444;
+    cpu->id_mmfr3 = 0x00102111;
+    cpu->isar.id_isar4 = 0x00011142;
+    cpu->clidr = 0x09200003;
+    cpu->ccsidr[0] = 0x700FE019;
+    cpu->ccsidr[1] = 0x200FE019;
+    cpu->reset_sctlr = 0x08C50078;  /* best guess */
+    //        1=MMU,        2=align,      4=DCache,    8=SBO        => 8
+    //       10=SBO,       20=SBO,       40=SBO,      80=SBZ        => 7
+    //      100=SBZ,      200=SBZ,      400=SWP,     800=Z(BP)      => 0 
+    //     1000=ICache,  2000=HIVECS,  4000=RR,     8000=SBZ        => 0
+    //    10000=SBO,    20000=SBZ,    40000=SBO,   80000=SBZ        => 5
+    //   100000=SBZ,   200000=SBZ,   400000=SBO,  800000=SBO        => C
+    //  1000000=SBZ,  2000000=EE,   4000000=SBZ, 8000000=NMFIQ      => 8
+    // 10000000=TRE, 20000000=AFE, 40000000=TE, 80000000=SBZ        => 0
+    // bic              0x1003005   (disable MMU, DCache, ICache, HIVECS, ???)
+    // orr             0x40000800   (enable branch predictor and Thumb exceptions)
+    // orr                   1005   (enable MMU, DCache, ICache)
+    // ->reset_sctlr = 0x48C5187D;  /* as printed by CHDK cpuinfo running from bootloader */
+    cpu->reset_auxcr = 0x00000045;  /* ACTLR */
+    //cpu->actlr2    = 0x00000201;
+    //cpu->cpacr     = 0xC0000000;
+    //cpu->dbgdidr   = TODO;
+}

 static void arm946_initfn(Object *obj)
 {
     ARMCPU *cpu = ARM_CPU(obj);
@@ -2026,9 +2026,20 @@ static void arm_v7m_class_init(ObjectClass *oc, void *data)
 
 static const ARMCPRegInfo cortexr5_cp_reginfo[] = {
     /* Dummy the TCM region regs for the moment */
-    { .name = "ATCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 0,
+    /* fixme: resetvalue hardcoded for DIGIC 6 */
+    { .name = "ATCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 1,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_atcm), .resetvalue = 0x00000015 },
+    { .name = "BTCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 0,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_btcm), .resetvalue = 0x8000001D },
+    { .name = "INV_DCACHE", .cp = 15, .opc1 = 0, .crn = 15, .crm = 5, .opc2 = 0,
+      .access = PL1_RW, .type = ARM_CP_CONST },
+    { .name = "BUILDOPTS",  .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = CP_ANY,
       .access = PL1_RW, .type = ARM_CP_CONST },
-    { .name = "BTCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 1,
+    { .name = "BUILDOPTS1", .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = 0,
+      .access = PL1_RW, .type = ARM_CP_CONST | ARM_CP_OVERRIDE, .resetvalue = 0x00010000 },
+    { .name = "BUILDOPTS2", .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = 1,
+      .access = PL1_RW, .type = ARM_CP_CONST | ARM_CP_OVERRIDE, .resetvalue = 0x00CFC010 },
+    { .name = "ACTLR2",     .cp = 15, .opc1 = 0, .crn = 15, .crm = 0, .opc2 = 0,
       .access = PL1_RW, .type = ARM_CP_CONST },
     REGINFO_SENTINEL
 };
@@ -2544,6 +2544,8 @@ static const ARMCPUInfo arm_cpus[] = {
 #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
     { .name = "arm926",      .initfn = arm926_initfn },
     { .name = "arm946",      .initfn = arm946_initfn },
+    { .name = "arm946-eos",  .initfn = arm946_eos_initfn },
+    { .name = "arm946-eos5", .initfn = arm946_eos5_initfn },
     { .name = "arm1026",     .initfn = arm1026_initfn },
     /* What QEMU calls "arm1136-r2" is actually the 1136 r0p2, i.e. an
      * older core than plain "arm1136". In particular this does not
@@ -2559,6 +2559,7 @@ static const ARMCPUInfo arm_cpus[] = {
                              .class_init = arm_v7m_class_init },
     { .name = "cortex-m4",   .initfn = cortex_m4_initfn,
                              .class_init = arm_v7m_class_init },
+    { .name = "cortex-r4-eos",.initfn = cortex_r4_eos_initfn },
     { .name = "cortex-m33",  .initfn = cortex_m33_initfn,
                              .class_init = arm_v7m_class_init },
     { .name = "cortex-r5",   .initfn = cortex_r5_initfn },
@@ -2567,5 +2567,6 @@ static const ARMCPUInfo arm_cpus[] = {
     { .name = "cortex-a8",   .initfn = cortex_a8_initfn },
     { .name = "cortex-a9",   .initfn = cortex_a9_initfn },
+    { .name = "cortex-a9-eos",.initfn = cortex_a9_eos_initfn },
     { .name = "cortex-a15",  .initfn = cortex_a15_initfn },
     { .name = "ti925t",      .initfn = ti925t_initfn },
     { .name = "sa1100",      .initfn = sa1100_initfn },
diff --git a/target-arm/cpu.h b/target-arm/cpu.h
index 815fef8..74ce4a9 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -389,6 +389,9 @@ typedef struct CPUARMState {
         uint64_t pmccfiltr_el0; /* Performance Monitor Filter Register */
         uint64_t vpidr_el2; /* Virtualization Processor ID Register */
         uint64_t vmpidr_el2; /* Virtualization Multiprocessor ID Register */
+
+        uint32_t c15_atcm;
+        uint32_t c15_btcm;
     } cp15;
 
     struct {
@@ -1849,6 +1849,7 @@ enum arm_features {
     ARM_FEATURE_VBAR, /* has cp15 VBAR */
     ARM_FEATURE_M_SECURITY, /* M profile Security Extension */
     ARM_FEATURE_M_MAIN, /* M profile Main Extension */
+    ARM_FEATURE_946EOS,    /* EOS-specific (DIGIC 2...5) */
 };
 
 static inline int arm_feature(CPUARMState *env, int feature)
diff --git a/target/arm/helper.c b/target/arm/helper.c
index afc4163..632ea26 100644
--- a/target/arm/helper.c
+++ b/target/arm/helper.c
@@ -549,6 +549,13 @@ static const ARMCPRegInfo not_v6_cp_reginfo[] = {
     REGINFO_SENTINEL
 };
 
+static const ARMCPRegInfo eos_wfi_cp_reginfo[] = {
+    /* similar to not_v6_cp_reginfo, but .crn was changed from 7 to 15 */
+    { .name = "WFI_v5", .cp = 15, .crn = 15, .crm = 8, .opc1 = 0, .opc2 = 2,
+      .access = PL1_W, .type = ARM_CP_WFI },
+    REGINFO_SENTINEL
+};
+
 static const ARMCPRegInfo not_v7_cp_reginfo[] = {
     /* Standard v6 WFI (also used in some pre-v6 cores); not in v7 (which
      * is UNPREDICTABLE; we choose to NOP as most implementations do).
@@ -598,6 +605,138 @@ static const ARMCPRegInfo not_v7_cp_reginfo[] = {
     REGINFO_SENTINEL
 };
 
+static const ARMCPRegInfo eos_tcm_cp_reginfo[] = {
+    { .name = "ITCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 1,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_atcm), .resetvalue = 0x00000006 },
+    { .name = "DTCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 0,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_btcm), .resetvalue = 0x40000006 },
+    REGINFO_SENTINEL
+};
+
+/* ARM946E-S (EOS) cache lockdown emulation */
+/* note: the model is very incomplete, just enough to emulate
+ * the cache hacks from Magic Lantern */
+
+struct cache_patch
+{
+    uint32_t addr;
+    uint32_t old;
+    uint32_t new;
+};
+
+static struct cache_patch cache_patches[32];
+
+static int num_cache_patches = 0;
+
+
+static uint64_t eos_cache_lockdown_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    fprintf(stderr, "Lockdown read %x\n", ri->crm);
+    return 0;
+}
+
+static void eos_cache_patch(uint32_t addr, uint32_t value)
+{
+    uint32_t old;
+    cpu_physical_memory_read(addr, &old, sizeof(old));
+    
+    if (value != old)
+    {
+        fprintf(stderr, "Cache patch: [%08X] <- %X (was %X)\n", addr, value, old);
+        cache_patches[num_cache_patches++] = (struct cache_patch) { .addr = addr, .old = old, .new = value };
+        cpu_physical_memory_write(addr, &value, sizeof(value));
+    }
+}
+
+static void eos_revert_cache_patches(void)
+{
+    for ( ; num_cache_patches > 0; num_cache_patches--)
+    {
+        struct cache_patch * p = &cache_patches[num_cache_patches - 1];
+        fprintf(stderr, "Reverting cache patch: [%08X] <- %X (was patched to %X)\n", p->addr, p->old, p->new);
+        cpu_physical_memory_write(p->addr, &p->old, sizeof(p->old));
+    }
+}
+
+static void eos_cache_lockdown_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t val)
+{
+    static uint32_t index = 0;
+    static uint32_t itag = 0;
+    static uint32_t dtag = 0;
+
+    /* FIXME: not exactly accurate, just a rough approximation */
+    /* no difference is made between data and instruction cache -
+     * first cache flush or lockdown disable event will revert all cache patches */
+    switch (ri->crn)
+    {
+        case 7:
+            /* FlushICache */
+            eos_revert_cache_patches();
+            return;
+
+        case 9:
+            /* DLockDown / ILockDown */
+            if (val == 0) {
+                eos_revert_cache_patches();
+            }
+            CPREG_FIELD32(env, ri) = val;
+            return;
+
+        case 15:
+            /* see the next switch */
+            break;
+
+        default:
+            /* unreachable */
+            assert(0);
+    }
+
+    switch (ri->crm)
+    {
+        case 0:             /* cache debug index register */
+            index = val;
+            break;
+        
+        case 1:             /* icache tag */
+            itag = val;
+            break;
+        
+        case 2:             /* dcache tag */
+            dtag = val;
+            break;
+        
+        case 3:             /* icache value */
+            eos_cache_patch((itag & 0xFFFFFFE0) | (index & 0x1C), val);
+            break;
+        
+        case 4:             /* dcache value */
+            eos_cache_patch((dtag & 0xFFFFFFE0) | (index & 0x1C), val);
+            break;
+    }
+}
+
+static const ARMCPRegInfo eos_lockdown_cp_reginfo[] = {
+    { .name = "CacheDbgIdx", .cp = 15, .crn = 15, .crm = 0, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "IcacheTag",   .cp = 15, .crn = 15, .crm = 1, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DcacheTag",   .cp = 15, .crn = 15, .crm = 2, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "IcacheVal",   .cp = 15, .crn = 15, .crm = 3, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DcacheVal",   .cp = 15, .crn = 15, .crm = 4, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DLockDown",   .cp = 15, .crn = 9,  .crm = 0, .opc1 = 0, .opc2 = 0,
+      .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_data),
+      .writefn = eos_cache_lockdown_write, .resetvalue = 0, .type = ARM_CP_OVERRIDE },
+    { .name = "ILockDown",   .cp = 15, .crn = 9,  .crm = 0, .opc1 = 0, .opc2 = 1,
+      .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_insn),
+      .writefn = eos_cache_lockdown_write, .resetvalue = 0, .type = ARM_CP_OVERRIDE },
+    { .name = "FlushICache", .cp = 15, .crn = 7, .crm = 5, .opc1 = 0, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    REGINFO_SENTINEL
+};
+
 static void cpacr_write(CPUARMState *env, const ARMCPRegInfo *ri,
                         uint64_t value)
 {
@@ -4410,7 +4549,7 @@ void register_cp_regs_for_features(ARMCPU *cpu)
             /* TCMTR and TLBTR exist in v8 but have no 64-bit versions */
             { .name = "TCMTR",
               .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 2,
-              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },
+              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->tcmtr },
             REGINFO_SENTINEL
         };
         /* TLBTR is specific to VMSA */
@@ -7056,6 +7056,13 @@ void register_cp_regs_for_features(ARMCPU *cpu)
         }
         define_one_arm_cp_reg(cpu, &sctlr);
     }
+
+    /* Features specific to DIGIC 2..5 (EOS) */
+    if (arm_feature(env, ARM_FEATURE_946EOS)) {
+        define_arm_cp_regs(cpu, eos_wfi_cp_reginfo);
+        define_arm_cp_regs(cpu, eos_lockdown_cp_reginfo);
+        define_arm_cp_regs(cpu, eos_tcm_cp_reginfo);
+    }
 
     if (cpu_isar_feature(aa64_lor, cpu)) {
         /*
@@ -7809,7 +7809,7 @@
     return target_el;
 }
 
-void arm_log_exception(int idx)
+void arm_log_exception(int idx, CPUARMState *env)
 {
     if (qemu_loglevel_mask(CPU_LOG_INT)) {
         const char *exc = NULL;
@@ -8448,7 +8448,7 @@
     unsigned int new_el = env->exception.target_el;
 
     assert(!arm_feature(env, ARM_FEATURE_M));
 
-    arm_log_exception(cs->exception_index);
+    arm_log_exception(cs->exception_index, env);
     qemu_log_mask(CPU_LOG_INT, "...from EL%d to EL%d\n", arm_current_el(env),
                   new_el);
     if (qemu_loglevel_mask(CPU_LOG_INT)
@@ -7982,7 +7982,7 @@ static inline void arm_log_exception(int idx)
         if (!exc) {
             exc = "unknown";
         }
-        qemu_log_mask(CPU_LOG_INT, "Taking exception %d [%s]\n", idx, exc);
+        qemu_log_mask(CPU_LOG_INT, "%08X: Taking exception %d [%s]\n", env->regs[15], idx, exc);
     }
 }
 
@@ -8090,13 +8090,19 @@ void arm_cpu_do_interrupt(CPUState *cs)
         env->thumb = (env->cp15.sctlr_el[2] & SCTLR_TE) != 0;
         env->elr_el[2] = env->regs[15];
     } else {
-        /*
-         * this is a lie, as there was no c1_sys on V4T/V5, but who cares
-         * and we should just guard the thumb mode on V4
-         */
-        if (arm_feature(env, ARM_FEATURE_V4T)) {
+        if (arm_feature(env, ARM_FEATURE_V6) ||
+            arm_feature(env, ARM_FEATURE_V7) ||
+            arm_feature(env, ARM_FEATURE_V8)) {
+            /* newer processors execute the interrupts in Thumb mode
+             * if the SCTLR TE bit is enabled */
             env->thumb =
                 (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_TE) != 0;
+        } else if (arm_feature(env, ARM_FEATURE_V4T)) {
+            /* there was no c1_sys on V4T/V5,
+             * and we should just guard the thumb mode on V4
+             * note: arm946eos uses the SCTLR TE bit for something else,
+             * so we can't assume this bit being always 0 on older platforms */
+            env->thumb = 0;
         }
         env->regs[14] = env->regs[15] + offset;
     }
--- a/target/arm/internals.h
+++ b/target/arm/internals.h
@@ -1051,7 +1051,7 @@
                    target_ulong *page_size,
                    ARMMMUFaultInfo *fi, ARMCacheAttrs *cacheattrs);
 
-void arm_log_exception(int idx);
+void arm_log_exception(int idx, CPUARMState *env);
 
 #endif /* !CONFIG_USER_ONLY */
 
--- a/target/arm/m_helper.c
+++ b/target/arm/m_helper.c
@@ -2042,7 +2042,7 @@ void arm_v7m_cpu_do_interrupt(CPUState *cs)
     uint32_t lr;
     bool ignore_stackfaults;
 
-    arm_log_exception(cs->exception_index);
+    arm_log_exception(cs->exception_index, env);
 
     /*
      * For exceptions we just mark as pending on the NVIC, and let that
diff --git a/target/arm/helper.h b/target/arm/helper.h
index c2a85c7..98aa94b 100644
--- a/target/arm/helper.h
+++ b/target/arm/helper.h
@@ -78,10 +78,15 @@ DEF_HELPER_2(v7m_mrs, i32, env, i32)
 
 DEF_HELPER_4(access_check_cp_reg, void, env, ptr, i32, i32)
 DEF_HELPER_3(set_cp_reg, void, env, ptr, i32)
 DEF_HELPER_2(get_cp_reg, i32, env, ptr)
+DEF_HELPER_3(print_set_cp_reg, void, env, ptr, i32)
+DEF_HELPER_3(print_get_cp_reg, void, env, ptr, i32)
 DEF_HELPER_3(set_cp_reg64, void, env, ptr, i64)
 DEF_HELPER_2(get_cp_reg64, i64, env, ptr)
 
+DEF_HELPER_3(log_ldr, void, i32, i32, i32)
+DEF_HELPER_3(log_str, void, i32, i32, i32)
+
 DEF_HELPER_2(get_r13_banked, i32, env, i32)
 DEF_HELPER_3(set_r13_banked, void, env, i32, i32)
 
diff --git a/target/arm/op_helper.c b/target/arm/op_helper.c
index 6cd54c8..055aaf7 100644
--- a/target/arm/op_helper.c
+++ b/target/arm/op_helper.c
@@ -474,6 +474,199 @@ void HELPER(set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
     ri->writefn(env, ri, value);
 }
 
+/* adapted from CHDK cpuinfo */
+static char linebuf[128];
+
+static const char *regperm_str(unsigned val) {
+    switch(val) {
+        case 0: return "P:-- U:--";
+        case 1: return "P:RW U:--";
+        case 2: return "P:RW U:R-";
+        case 3: return "P:RW U:RW";
+        case 5: return "P:R- U:--";
+        case 6: return "P:R- U:R-";
+        default:
+            return "P:?? U:??";
+    }
+}
+
+static const char *mpu_rattr(unsigned val) {
+    const char *s="";
+    const char *s2="";
+    const char *t;
+    t = (val&4)?"Shared":"Non-shared";
+    if (val&0x20) {
+        switch (val&3) {
+            case 0: s = "Inner Non-cacheable"; break;
+            case 1: s = "Inner Write-back, write-allocate"; break;
+            case 2: s = "Inner Write-through, no write-allocate"; break;
+            case 3: s = "Inner Write-back, no write-allocate"; break;
+        }
+        switch ((val&0x18)>>3) {
+            case 0: s2 = "Outer Non-cacheable"; break;
+            case 1: s2 = "Outer Write-back, write-allocate"; break;
+            case 2: s2 = "Outer Write-through, no write-allocate"; break;
+            case 3: s2 = "Outer Write-back, no write-allocate"; break;
+        }
+        sprintf(linebuf,"%s; %s; %s",s, s2, t);
+    }
+    else {
+        switch (val&0x1B) {
+            case 0: s = "Strongly ordered, shareable"; t=""; break;
+            case 1: s = "Shareable device"; t="Shareable"; break;
+            case 2: s = "Outer and Inner write-through, no write-allocate"; break;
+            case 3: s = "Outer and Inner write-back, no write-allocate"; break;
+            case 8: s = "Outer and Inner Non-cacheable"; break;
+            case 11: s = "Outer and Inner write-back, write-allocate"; break;
+            case 16: s = "Non-shareable Device"; t=""; break;
+            default: s = "(reserved)"; t="";
+        }
+        sprintf(linebuf,"%s; %s",s, t);
+    }
+    return linebuf;
+}
+
+static void print_cpu_mpidr(CPUARMState *env)
+{
+    if (arm_feature(env, ARM_FEATURE_V7MP)) {
+        ARMCPU *cpu = env_archcpu(env);
+        uint64_t mpidr = cpu->mp_affinity;
+        fprintf(stderr, "[CPU%d] ", (int) mpidr & 0xFF);
+    }
+}
+
+void HELPER(print_set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
+{
+    const ARMCPRegInfo *ri = rip;
+    char desc[256] = "";
+
+    if (strcmp(ri->name, "DSB") == 0)
+    {
+        return;
+    }
+    
+    /* CACHEMAINT registers come in very large groups;
+     * just display how many calls there were.
+     * fixme: if there are MRC calls, the display order may be wrong
+     */
+    static int cachemaint_count = 0;
+    static uint32_t cachemaint_pc = 0;
+    if (strcmp(ri->name, "CACHEMAINT") == 0)
+    {
+        cachemaint_pc = env->regs[15];
+        cachemaint_count++;
+        return;
+    }
+    else
+    {
+        if (cachemaint_count)
+        {
+            print_cpu_mpidr(env);
+            fprintf(stderr, "%08X: MCR p%d, ...          : CACHEMAINT x%d (omitted)\n", cachemaint_pc, ri->cp, cachemaint_count);
+            cachemaint_count = 0;
+        }
+    }
+
+    if (strncmp(ri->name, "946_PRBS", 8) == 0 &&
+        (value & 1))
+    {
+        uint64_t base = value & 0xFFFFF000;
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 1);
+        uint64_t end = base + size - 1;
+        snprintf(desc, sizeof(desc), "(%08"PRIX64" - %08"PRIX64", 0x%"PRIX64")", base, end, size);
+
+        /* workaround to emulate io_trace */
+        /* fixme - proper solution? */
+        ARMCPU *cpu = env_archcpu(env);
+        tlb_flush(CPU(cpu));
+    }
+
+    if (strcmp(ri->name+1, "TCM") == 0)
+    {
+        uint64_t base = value & 0xFFFFF000;
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 9);
+        uint64_t end = base + size - 1;
+        snprintf(desc, sizeof(desc), "(%08"PRIX64" - %08"PRIX64", 0x%"PRIX64")", base, end, size);
+    }
+
+    if (strcmp(ri->name, "DRSR") == 0 &&
+        (value & 1))
+    {
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 1);
+        snprintf(desc, sizeof(desc), "(0x%"PRIX64")", size);
+
+        uint32_t rgnr = env->pmsav7.rnr[M_REG_NS];
+        uint32_t base = env->pmsav7.drbar[rgnr];
+        assert(base % size == 0);
+
+        /* subregion disable bits */
+        uint32_t subregion_disable = (value & 0xFF00) >> 8;
+        if (subregion_disable)
+        {
+            /* Region sizes of less than 256 bytes do not support subregions
+             * (Cortex R4 TRM, 7.1.1 Memory regions) */
+            assert(size >= 256);
+
+            uint32_t subregion_size = size / 8;
+            for (int i = 0; i < 8; i++)
+            {
+                fprintf(stderr,
+                    "Subregion %08X - %08X: %s\n",
+                    base + subregion_size * i,
+                    base + subregion_size * (i + 1) - 1,
+                    subregion_disable & (1 << i) ? "disabled" : "enabled"
+                );
+            }
+        }
+    }
+
+    if (strcmp(ri->name, "DRACR") == 0)
+    {
+        uint32_t rattr = value & 0x3F;
+        uint32_t accpm = (value >> 8) & 3;
+        uint32_t xn    = (value >> 12) & 1;
+        snprintf(desc, sizeof(desc),
+            "(%s; %s%s)",
+            regperm_str(accpm),
+            mpu_rattr(rattr),
+            xn ? "; Execute never" : ""
+        );
+    }
+
+    print_cpu_mpidr(env);
+    fprintf(stderr, "%08X: MCR p%d,%d,Rd,cr%d,cr%d,%d: %10s <- 0x%-8X %s\n",
+        env->regs[15], ri->cp,
+        ri->opc1, ri->crn, ri->crm, ri->opc2,
+        ri->name, value, desc
+    );
+}
+
+void HELPER(print_get_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
+{
+    const ARMCPRegInfo *ri = rip;
+
+    print_cpu_mpidr(env);
+    fprintf(stderr, "%08X: MRC p%d,%d,Rd,cr%d,cr%d,%d: %10s -> 0x%X\n",
+        env->regs[15], ri->cp,
+        ri->opc1, ri->crn, ri->crm, ri->opc2,
+        ri->name, value
+    );
+}
+
+/* fixme: how to pass a pointer here, to call the registered CBR directly? */
+extern void log_ldr_cb(uint32_t addr, uint32_t value, uint32_t opc);
+extern void log_str_cb(uint32_t addr, uint32_t value, uint32_t opc);
+
+void HELPER(log_ldr)(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    log_ldr_cb(addr, value, opc);
+}
+
+void HELPER(log_str)(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    log_str_cb(addr, value, opc);
+}
+
 uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)
 {
     const ARMCPRegInfo *ri = rip;
diff --git a/target/arm/translate.c b/target/arm/translate.c
index 5d22879..a413e2c 100644
--- a/target/arm/translate.c
+++ b/target/arm/translate.c
@@ -37,6 +37,8 @@
 
 #include "trace-tcg.h"
 
+#define LOG_ALL_CP_READS
+#define LOG_ALL_CP_WRITES
 
 #define ENABLE_ARCH_4T    arm_dc_feature(s, ARM_FEATURE_V4T)
 #define ENABLE_ARCH_5     arm_dc_feature(s, ARM_FEATURE_V5)
@@ -962,11 +962,78 @@
     tcg_temp_free(addr);
 }
 
+/* fixme: should be moved to memory.c and accessed somehow from there? */
+/* fixme: use MemoryRegionOps? The read callback doesn't accept address and value */
+struct mem_log
+{
+    void (*read_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write);
+    void * read_arg;
+    void (*write_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write);
+    void * write_arg;
+} mem_log;
+
+void memory_set_access_logging_cb(
+    void (*mem_log_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write),
+    void * opaque, int access_mode)
+{
+    if (access_mode & PROT_READ) {
+        mem_log.read_cb = mem_log_cb;
+        mem_log.read_arg = opaque;
+    }
+    if (access_mode & PROT_WRITE) {
+        mem_log.write_cb = mem_log_cb;
+        mem_log.write_arg = opaque;
+    }
+}
+
+/* called from helper_log_ldr */
+void log_ldr_cb(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    if (mem_log.read_cb) {
+        unsigned size = 1 << (opc & MO_SIZE);
+        mem_log.read_cb(mem_log.read_arg, addr, value, size, 0);
+    }
+}
+
+/* called from helper_log_str */
+void log_str_cb(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    if (mem_log.write_cb) {
+        unsigned size = 1 << (opc & MO_SIZE);
+        mem_log.write_cb(mem_log.write_arg, addr, value, size, 1);
+    }
+}
+
+static inline void gen_log_ldr(TCGv_i32 addr, TCGv_i32 val, int opc)
+{
+    /* called after the actual LDR, to get the value too */
+    /* only compile the logging code if a CBR was registered */
+    if (mem_log.read_cb) {
+        TCGv_i32 opc_reg = tcg_temp_new_i32();
+        tcg_gen_movi_i32(opc_reg, opc);
+        gen_helper_log_ldr(addr, val, opc_reg);
+        tcg_temp_free_i32(opc_reg);
+    }
+}
+
+static inline void gen_log_str(TCGv_i32 addr, TCGv_i32 val, int opc)
+{
+    /* called before the actual STR */
+    /* only compile the logging code if a CBR was registered */
+    if (mem_log.write_cb) {
+        TCGv_i32 opc_reg = tcg_temp_new_i32();
+        tcg_gen_movi_i32(opc_reg, opc);
+        gen_helper_log_str(addr, val, opc_reg);
+        tcg_temp_free_i32(opc_reg);
+    }
+}
+
 #define DO_GEN_LD(SUFF, OPC)                                             \
 static inline void gen_aa32_ld##SUFF(DisasContext *s, TCGv_i32 val,      \
                                      TCGv_i32 a32, int index)            \
 {                                                                        \
     gen_aa32_ld_i32(s, val, a32, index, OPC | s->be_data);               \
+    gen_log_ldr(a32, val, OPC);                                          \
 }
 
 #define DO_GEN_ST(SUFF, OPC)                                             \
@@ -974,6 +1041,7 @@
                                      TCGv_i32 a32, int index)            \
 {                                                                        \
     gen_aa32_st_i32(s, val, a32, index, OPC | s->be_data);               \
+    gen_log_str(a32, val, OPC);                                          \
 }
 
 static inline void gen_aa32_frob64(DisasContext *s, TCGv_i64 val)
@@ -996,6 +1064,10 @@
 static inline void gen_aa32_ld64(DisasContext *s, TCGv_i64 val,
                                  TCGv_i32 a32, int index)
 {
+    if (mem_log.read_cb) {
+        /* not implemented */
+        assert(0);
+    }
     gen_aa32_ld_i64(s, val, a32, index, MO_Q | s->be_data);
 }
 
@@ -1019,6 +1091,10 @@
 static inline void gen_aa32_st64(DisasContext *s, TCGv_i64 val,
                                  TCGv_i32 a32, int index)
 {
+    if (mem_log.write_cb) {
+        /* not implemented */
+        assert(0);
+    }
     gen_aa32_st_i64(s, val, a32, index, MO_Q | s->be_data);
 }
 
@@ -7222,6 +7300,27 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
         /* Handle special cases first */
         switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {
         case ARM_CP_NOP:
+            #if defined(LOG_ALL_CP_READS) || defined(LOG_ALL_CP_WRITES)
+            if (!is64) {
+                /* log all reads to coprocessor registers (32-bit) */
+                TCGv_ptr tmpptr;
+                TCGv_i32 tmp;
+                tmpptr = tcg_const_ptr(ri);
+                if (isread) {
+                    #ifdef LOG_ALL_CP_READS
+                    tmp = load_cpu_offset(ri->fieldoffset);
+                    gen_helper_print_get_cp_reg(cpu_env, tmpptr, tmp);
+                    #endif
+                } else {
+                    #ifdef LOG_ALL_CP_WRITES
+                    tmp = load_reg(s, rt);
+                    gen_helper_print_set_cp_reg(cpu_env, tmpptr, tmp);
+                    #endif
+                }
+                tcg_temp_free_ptr(tmpptr);
+                tcg_temp_free_i32(tmp);
+            }
+            #endif
             return 0;
         case ARM_CP_WFI:
             if (isread) {
@@ -7276,6 +7375,15 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
                 } else {
                     tmp = load_cpu_offset(ri->fieldoffset);
                 }
+
+                #ifdef LOG_ALL_CP_READS
+                /* log all reads to coprocessor registers (32-bit) */
+                TCGv_ptr tmpptr;
+                tmpptr = tcg_const_ptr(ri);
+                gen_helper_print_get_cp_reg(cpu_env, tmpptr, tmp);
+                tcg_temp_free_ptr(tmpptr);
+                #endif
+
                 if (rt == 15) {
                     /* Destination register of r15 for 32 bit loads sets
                      * the condition codes from the high 4 bits of the value
@@ -7287,6 +7395,19 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
                 }
             }
         } else {
+            #ifdef LOG_ALL_CP_WRITES
+            if (!is64) {
+                /* log all writes to coprocessor registers (32-bit) */
+                TCGv_i32 tmp;
+                TCGv_ptr tmpptr;
+                tmp = load_reg(s, rt);
+                tmpptr = tcg_const_ptr(ri);
+                gen_helper_print_set_cp_reg(cpu_env, tmpptr, tmp);
+                tcg_temp_free_ptr(tmpptr);
+                tcg_temp_free_i32(tmp);
+            }
+            #endif
+            
             /* Write */
             if (ri->type & ARM_CP_CONST) {
                 /* If not forbidden by access permissions, treat as WI */
diff --git a/target/arm/translate.h b/target/arm/translate.h
index 53ef971..260331a 100644
--- a/target/arm/translate.h
+++ b/target/arm/translate.h
@@ -151,4 +151,8 @@ void arm_free_cc(DisasCompare *cmp);
 void arm_jump_cc(DisasCompare *cmp, TCGLabel *label);
 void arm_gen_test_cc(int cc, TCGLabel *label);
 
+/* fixme: duplicate declaration in op_helper.c */
+void log_ldr_cb(uint32_t addr, uint32_t value, uint32_t opc);
+void log_str_cb(uint32_t addr, uint32_t value, uint32_t opc);
+
 #endif /* TARGET_ARM_TRANSLATE_H */
diff --git a/vl.c b/vl.c
index 4211ff1..93d4df4 100644
--- a/vl.c
+++ b/vl.c
@@ -4102,7 +4102,7 @@ int main(int argc, char **argv, char **envp)
     }
 
     if (log_mask) {
-        int mask;
+        uint64_t mask;
         mask = qemu_str_to_log_mask(log_mask);
         if (!mask) {
             qemu_print_log_usage(stdout);
